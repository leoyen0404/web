<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAVAICE.IO</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00ffff;
            --secondary: #ff4b4b;
            --bg: #121212;
            --panel-bg: rgba(20, 20, 35, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            user-select: none;
        }

        /* IO Style Grid Background */
        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .hud-panel {
            background: var(--panel-bg);
            padding: 15px 25px;
            border-radius: 16px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            color: #fff;
            font-weight: 800;
            letter-spacing: 1px;
            line-height: 1;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #aaa;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .bar-container {
            width: 220px;
            height: 14px;
            background: rgba(0,0,0,0.6);
            border-radius: 7px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
            position: relative;
        }

        .bar-fill::after {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
        }

        #hp-bar { background: linear-gradient(90deg, #ff3333, #ff6b6b); }
        #dash-bar { background: linear-gradient(90deg, #00d2ff, #3a7bd5); }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 30;
            background: var(--panel-bg);
            padding: 60px;
            border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        #game-over h1 {
            color: var(--secondary);
            font-size: 3.5rem;
            margin-bottom: 10px;
        }

        #game-over p {
            font-size: 1.2rem;
            color: #ddd;
            margin: 10px 0;
        }

        .btn {
            background: linear-gradient(45deg, var(--secondary), #ff8e53);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 1.2rem;
            font-weight: 800;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 75, 75, 0.4);
            transition: transform 0.1s;
            font-family: 'Poppins', sans-serif;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            font-weight: 600;
            background: rgba(0,0,0,0.4);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-panel">
            <div class="stat-label">Score</div>
            <h1 id="score-display">0</h1>
        </div>
        <div class="hud-panel">
            <div class="stat-label">Wave <span id="wave-display" style="color:white; margin-left:5px;">1</span></div>
        </div>
        <div class="hud-panel">
            <div class="stat-label">Integrity</div>
            <div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div>
            <div class="stat-label" style="margin-top:5px;">Energy</div>
            <div class="bar-container"><div id="dash-bar" class="bar-fill"></div></div>
        </div>
    </div>

    <div id="game-over">
        <h1>ELIMINATED</h1>
        <p id="final-score">Score: 0</p>
        <button class="btn" onclick="resetGame()">REBOOT SYSTEM</button>
    </div>

    <div class="controls-hint">
        WASD to Move • ARROWS to Shoot • SPACE to Dash
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * LAVICE.IO
         * Classic IO style redesign with Lavice material.
         */

        // --- FAST NOISE (Permutation Table) ---
        const Simplex = (function() {
            const p = new Uint8Array(256);
            for(let i=0; i<256; i++) p[i] = i;
            for(let i=255; i>0; i--) {
                const r = Math.floor(Math.random() * (i+1));
                [p[i], p[r]] = [p[r], p[i]];
            }
            const perm = new Uint8Array(512);
            const permMod12 = new Uint8Array(512);
            for(let i=0; i<512; i++) {
                perm[i] = p[i & 255];
                permMod12[i] = perm[i] % 12;
            }
            const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
            
            return {
                noise3D: function(xin, yin, zin) {
                    let n0, n1, n2, n3;
                    const F3 = 1.0/3.0;
                    const s = (xin+yin+zin)*F3;
                    const i = Math.floor(xin+s);
                    const j = Math.floor(yin+s);
                    const k = Math.floor(zin+s);
                    const G3 = 1.0/6.0;
                    const t = (i+j+k)*G3;
                    const X0 = i-t;
                    const Y0 = j-t;
                    const Z0 = k-t;
                    const x0 = xin-X0;
                    const y0 = yin-Y0;
                    const z0 = zin-Z0;
                    let i1, j1, k1;
                    let i2, j2, k2;
                    if(x0>=y0) {
                        if(y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                        else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                        else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                    } else {
                        if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                        else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                        else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                    }
                    const x1 = x0 - i1 + G3;
                    const y1 = y0 - j1 + G3;
                    const z1 = z0 - k1 + G3;
                    const x2 = x0 - i2 + 2.0*G3;
                    const y2 = y0 - j2 + 2.0*G3;
                    const z2 = z0 - k2 + 2.0*G3;
                    const x3 = x0 - 1.0 + 3.0*G3;
                    const y3 = y0 - 1.0 + 3.0*G3;
                    const z3 = z0 - 1.0 + 3.0*G3;
                    const ii = i & 255;
                    const jj = j & 255;
                    const kk = k & 255;
                    const gi0 = permMod12[ii+perm[jj+perm[kk]]];
                    const gi1 = permMod12[ii+i1+perm[jj+j1+perm[kk+k1]]];
                    const gi2 = permMod12[ii+i2+perm[jj+j2+perm[kk+k2]]];
                    const gi3 = permMod12[ii+1+perm[jj+1+perm[kk+1]]];
                    let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                    if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * (grad3[gi0][0]*x0 + grad3[gi0][1]*y0 + grad3[gi0][2]*z0); }
                    let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                    if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * (grad3[gi1][0]*x1 + grad3[gi1][1]*y1 + grad3[gi1][2]*z1); }
                    let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                    if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * (grad3[gi2][0]*x2 + grad3[gi2][1]*y2 + grad3[gi2][2]*z2); }
                    let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                    if(t3<0) n3 = 0.0; else { t3 *= t3; n3 = t3 * t3 * (grad3[gi3][0]*x3 + grad3[gi3][1]*y3 + grad3[gi3][2]*z3); }
                    return 32.0*(n0 + n1 + n2 + n3);
                }
            };
        })();

        // --- GAME CONSTANTS ---
        const CELL_SIZE = 8; // Finer grid for better Lavice texture
        const WALL_THRESHOLD = 0.15; 
        const NOISE_SCALE = 0.05;
        const TIME_SCALE = 0.1; 

        // --- ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, cols, rows;

        // --- STATE ---
        let gameTime = 0;
        let score = 0;
        let wave = 1;
        let isGameOver = false;
        let shake = 0;

        // --- ENTITIES ---
        const player = {
            x: 0, y: 0,
            radius: 12,
            speed: 4,
            dashSpeed: 15,
            isDashing: false,
            dashCooldown: 0,
            dashMax: 50,
            dashDuration: 0,
            vx: 0, vy: 0,
            hp: 100,
            maxHp: 100,
            color: '#fff'
        };

        let bullets = [];
        let enemies = [];
        let particles = [];
        
        // --- INPUT ---
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => {
            keys[e.code] = false;
            if(e.code === 'Space' && isGameOver) resetGame();
            else if(e.code === 'Space') tryDash();
        });

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            cols = Math.ceil(width / CELL_SIZE);
            rows = Math.ceil(height / CELL_SIZE);
            findSafeSpawn();
        }
        window.addEventListener('resize', resize);
        resize();

        function findSafeSpawn() {
            let attempts = 0;
            let safe = false;
            while(!safe && attempts < 100) {
                let tx = Math.random() * width;
                let ty = Math.random() * height;
                if (!isWall(tx, ty)) {
                    player.x = tx;
                    player.y = ty;
                    safe = true;
                }
                attempts++;
            }
            if (!safe) {
                player.x = width/2;
                player.y = height/2;
            }
        }

        function resetGame() {
            score = 0;
            wave = 1;
            gameTime = 0;
            isGameOver = false;
            enemies = [];
            bullets = [];
            particles = [];
            findSafeSpawn();
            player.hp = player.maxHp;
            player.dashCooldown = 0;
            document.getElementById('game-over').style.display = 'none';
        }

        function tryDash() {
            if (player.dashCooldown <= 0) {
                player.isDashing = true;
                player.dashDuration = 8;
                player.dashCooldown = player.dashMax;
                if (player.vx === 0 && player.vy === 0) player.vy = -1;
                
                // Dash particles
                for(let i=0; i<12; i++) {
                    particles.push({
                        x: player.x, y: player.y,
                        vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8,
                        life: 25, color: '#00ffff', size: 4
                    });
                }
            }
        }

        // --- CORE FUNCTIONS ---
        
        // Returns noise value at x,y
        function getNoise(x, y) {
            return Simplex.noise3D(x * NOISE_SCALE / CELL_SIZE, y * NOISE_SCALE / CELL_SIZE, gameTime * TIME_SCALE);
        }

        function isWall(x, y) {
            if (x < 0 || x > width || y < 0 || y > height) return true;
            return getNoise(x, y) > WALL_THRESHOLD;
        }

        function spawnEnemy() {
            let ex, ey, attempts = 0;
            do {
                ex = Math.random() * width;
                ey = Math.random() * height;
                attempts++;
            } while (isWall(ex, ey) && attempts < 50);

            if (attempts < 50) {
                // New Enemy Types: Lava Debris (Heavy) & Ice Dust (Fast)
                const type = Math.random() > 0.7 ? 'ice_dust' : 'lava_debris';
                enemies.push({
                    x: ex, y: ey,
                    type: type,
                    speed: type === 'ice_dust' ? 3.5 : 1.5,
                    hp: type === 'ice_dust' ? 1 : 5,
                    radius: type === 'ice_dust' ? 8 : 14,
                    color: type === 'ice_dust' ? '#aaddff' : '#ff5500',
                    angle: 0
                });
            }
        }

        // --- LOOP ---
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            if (isGameOver) return;

            gameTime += 0.01;
            
            if (Math.random() < 0.008 + (wave * 0.0005)) spawnEnemy();
            if (score > wave * 1200) wave++;

            // --- PLAYER MOVEMENT ---
            let dx = 0;
            let dy = 0;
            if (keys['KeyW']) dy = -1;
            if (keys['KeyS']) dy = 1;
            if (keys['KeyA']) dx = -1;
            if (keys['KeyD']) dx = 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                dx /= len;
                dy /= len;
            }

            let currentSpeed = player.isDashing ? player.dashSpeed : player.speed;
            
            // LAVICE EFFECT: Freeze Inside
            // Check if player is inside Lavice
            const noiseVal = getNoise(player.x, player.y);
            const inLavice = noiseVal > WALL_THRESHOLD;
            
            if (inLavice && !player.isDashing) {
                // Freeze effect: Slow down significantly
                currentSpeed *= 0.2;
                // Burnt effect: Take damage
                player.hp -= 0.5;
                
                // Visual feedback for burning/freezing
                if (Math.random() < 0.3) {
                    particles.push({
                        x: player.x + (Math.random()-0.5)*10,
                        y: player.y + (Math.random()-0.5)*10,
                        vx: 0, vy: -1,
                        life: 10, color: '#ff0000', size: 2
                    });
                }
            }

            player.vx = dx * currentSpeed;
            player.vy = dy * currentSpeed;

            let nextX = player.x + player.vx;
            let nextY = player.y + player.vy;

            // Collision with Lavice Surface (Burnt on touch)
            // We no longer stop the player hard, but we punish touching the "wall"
            // Actually, classic IO usually has walls you collide with.
            // Let's keep collision but add "Burnt" damage when touching.
            
            if (!player.isDashing) {
                // Predictive collision for sliding
                if (!isWall(nextX, player.y)) {
                    player.x = nextX;
                } else {
                    player.vx = 0;
                    // Touching wall X -> Burn
                    player.hp -= 0.2;
                }

                if (!isWall(player.x, nextY)) {
                    player.y = nextY;
                } else {
                    player.vy = 0;
                    // Touching wall Y -> Burn
                    player.hp -= 0.2;
                }
            } else {
                player.x = nextX;
                player.y = nextY;
                player.dashDuration--;
                if (player.dashDuration <= 0) player.isDashing = false;
            }
            
            // HP Check
            if (player.hp <= 0) die();
            if (player.hp < player.maxHp) player.hp += 0.05; // Slow regen? Or maybe not. Let's add very slow regen.

            // Cooldowns
            if (player.dashCooldown > 0) player.dashCooldown--;

            // --- SHOOTING ---
            let shootX = 0; 
            let shootY = 0;
            if (keys['ArrowUp']) shootY = -1;
            else if (keys['ArrowDown']) shootY = 1;
            if (keys['ArrowLeft']) shootX = -1;
            else if (keys['ArrowRight']) shootX = 1;

            if ((shootX !== 0 || shootY !== 0) && frame % 8 === 0) {
                bullets.push({
                    x: player.x, y: player.y,
                    vx: shootX * 12, vy: shootY * 12,
                    life: 50
                });
            }

            // --- ENTITIES UPDATE ---
            
            // Bullets
            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                
                if (isWall(b.x, b.y)) {
                    bullets.splice(i, 1);
                    particles.push({x:b.x, y:b.y, vx: -b.vx*0.3, vy: -b.vy*0.3, life:10, color:'#fff', size:2});
                    continue;
                }
                if (b.life <= 0) bullets.splice(i, 1);
            }

            // Enemies
            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                let dx = player.x - e.x;
                let dy = player.y - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 0) {
                    e.x += (dx/dist) * e.speed;
                    e.y += (dy/dist) * e.speed;
                }
                
                // Rotate debris
                e.angle += 0.1;

                if (isWall(e.x, e.y)) {
                    e.x -= (dx/dist) * e.speed;
                    if (isWall(e.x, e.y)) e.y -= (dy/dist) * e.speed;
                }

                if (dist < player.radius + e.radius && !player.isDashing) {
                    player.hp -= 10; // Contact damage
                    shake = 5;
                    // Push back
                    player.x += (dx/dist) * 20;
                    player.y += (dy/dist) * 20;
                }

                for(let j=bullets.length-1; j>=0; j--) {
                    let b = bullets[j];
                    let bDist = Math.hypot(b.x - e.x, b.y - e.y);
                    if (bDist < e.radius + 8) {
                        e.hp--;
                        bullets.splice(j, 1);
                        particles.push({x:e.x, y:e.y, vx:0, vy:0, life:5, color:'#fff', size: e.radius});
                        
                        if (e.hp <= 0) {
                            enemies.splice(i, 1);
                            score += e.type === 'ice_dust' ? 150 : 400;
                            for(let k=0; k<8; k++) {
                                particles.push({
                                    x: e.x, y: e.y,
                                    vx: (Math.random()-0.5)*8,
                                    vy: (Math.random()-0.5)*8,
                                    life: 30,
                                    color: e.color,
                                    size: 4
                                });
                            }
                        }
                        break;
                    }
                }
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if(p.life <= 0) particles.splice(i,1);
            }

            // UI Update
            document.getElementById('score-display').innerText = score.toLocaleString();
            document.getElementById('wave-display').innerText = wave;
            
            let dashPct = (1 - (player.dashCooldown / player.dashMax)) * 100;
            if(player.dashCooldown <= 0) dashPct = 100;
            document.getElementById('dash-bar').style.width = dashPct + "%";
            
            let hpPct = (player.hp / player.maxHp) * 100;
            document.getElementById('hp-bar').style.width = Math.max(0, hpPct) + "%";

            if(shake > 0) shake *= 0.9;
        }

        function die() {
            isGameOver = true;
            shake = 0;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = "Score: " + score;
        }

        let frame = 0;

        // --- RENDER ---
        function draw() {
            let sx = (Math.random()-0.5) * shake;
            let sy = (Math.random()-0.5) * shake;

            ctx.clearRect(0, 0, width, height); // Clear for transparent bg (grid is in body)

            ctx.save();
            ctx.translate(sx, sy);

            // 1. Draw LAVICE (The Living Terrain)
            // We iterate grid
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const wx = x * CELL_SIZE;
                    const wy = y * CELL_SIZE;
                    
                    const n = getNoise(wx+CELL_SIZE/2, wy+CELL_SIZE/2);
                    
                    if (n > WALL_THRESHOLD) {
                        // Lavice Material: Liquid Glass Texture
                        // Gradient from Lava (Surface) to Ice (Deep)
                        let t = (n - WALL_THRESHOLD) * 2.5; 
                        if (t > 1) t = 1;
                        
                        // Color Interpolation
                        const r = Math.floor(255 * (1-t) + 31 * t);
                        const g = Math.floor(75 * (1-t) + 221 * t);
                        const b = Math.floor(31 * (1-t) + 255 * t);
                        
                        // Liquid Glass Effect
                        // 1. Semi-transparent base
                        ctx.fillStyle = `rgba(${r},${g},${b}, 0.6)`;
                        // Overlap slightly to remove grid lines
                        ctx.fillRect(wx, wy, CELL_SIZE+1, CELL_SIZE+1);

                        // 2. Subtle Highlight (Soft Glow)
                        // Instead of a hard block, we use a smaller, centered highlight
                        // ctx.fillStyle = `rgba(255,255,255, 0.15)`;
                        // ctx.fillRect(wx + 2, wy + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    }
                }
            }

            // 2. Draw Entities
            
            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Enemies
            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                ctx.rotate(e.angle);
                
                ctx.fillStyle = e.color;
                ctx.shadowColor = e.color;
                ctx.shadowBlur = 15;
                
                if (e.type === 'lava_debris') {
                    // Square/Jagged shape
                    ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2);
                } else {
                    // Ice Dust: Triangle or Diamond
                    ctx.beginPath();
                    ctx.moveTo(0, -e.radius);
                    ctx.lineTo(e.radius, 0);
                    ctx.lineTo(0, e.radius);
                    ctx.lineTo(-e.radius, 0);
                    ctx.fill();
                }
                
                ctx.restore();
            });

            // Bullets
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 5;
            bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Player
            if (!isGameOver) {
                ctx.fillStyle = player.isDashing ? '#00ffff' : '#ffffff';
                ctx.shadowColor = player.isDashing ? '#00ffff' : '#ffffff';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
                ctx.fill();
                
                // Direction indicator
                // ctx.strokeStyle = '#333';
                // ctx.lineWidth = 2;
                // ctx.beginPath();
                // ctx.moveTo(player.x, player.y);
                // ctx.lineTo(player.x + player.vx*5, player.y + player.vy*5);
                // ctx.stroke();
                
                ctx.shadowBlur = 0;
            }

            ctx.restore();
            frame++;
        }

        loop();

    </script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="bot.js"></script>
</body>
</html>
