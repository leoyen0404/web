<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glassmorphism Phone UI Demo with Continuous Corners & App Open Animation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Custom styles for the demo */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            overflow: hidden; /* Prevent scrollbars during animation */
            background: linear-gradient(to bottom right, #f0f4f8, #d9e2ec);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Phone Frame Styles - Uses mask */
        .phone-frame {
            width: 320px;
            height: 640px;
            background-color: #111827;
            /* border-radius removed */
            padding: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35), inset 0 0 0 3px rgba(255,255,255,0.05);
            position: relative;
            overflow: hidden; /* Keep for mask */
            /* Mask properties applied by JS */
        }

        /* Phone Screen Styles - Uses mask */
        .phone-screen {
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* Fallback */
            /* border-radius removed */
            position: relative; /* Needed for absolute positioning of children */
            overflow: hidden; /* Clip background elements */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px 15px;
            /* Mask properties applied by JS */
            --phone-screen-radius: 60px;
        }

        /* Container for the MOVING wallpaper blocks */
        .background-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            /* Mask on parent handles clipping */
        }

        /* MOVING Wallpaper Block Styles */
        .color-block {
            position: absolute;
            opacity: 0.85;
            animation: move 25s infinite linear alternate;
            will-change: transform, border-radius;
        }

        /* Define wallpaper blocks */
         .block-1 { background-color: #0077b6; width: 180px; height: 250px; top: -30px; left: -50px; border-radius: 30% 70% 50% 50% / 30% 30% 70% 70%; transform: rotate(-15deg); animation-duration: 28s; --initial-rotate: -15deg; --initial-radius: 30% 70% 50% 50% / 30% 30% 70% 70%; }
        .block-2 { background-color: #ffb703; width: 220px; height: 180px; top: 150px; left: 80px; border-radius: 70% 30% 80% 20% / 60% 70% 30% 40%; transform: rotate(25deg); opacity: 0.8; animation-duration: 24s; animation-delay: -7s; --initial-rotate: 25deg; --initial-radius: 70% 30% 80% 20% / 60% 70% 30% 40%; }
        .block-3 { background-color: #e63946; width: 150px; height: 200px; bottom: -40px; left: 20px; border-radius: 50% 50% 30% 70% / 60% 40% 60% 40%; transform: rotate(10deg); animation-duration: 30s; animation-delay: -12s; --initial-rotate: 10deg; --initial-radius: 50% 50% 30% 70% / 60% 40% 60% 40%; }
        .block-4 { background-color: #2ec4b6; width: 190px; height: 160px; top: 350px; right: -60px; border-radius: 40% 60% 70% 30% / 50% 60% 40% 50%; transform: rotate(-30deg); opacity: 0.75; animation-duration: 26s; animation-delay: -18s; --initial-rotate: -30deg; --initial-radius: 40% 60% 70% 30% / 50% 60% 40% 50%; }
         .block-5 { background-color: #fb8500; width: 120px; height: 100px; top: 80px; left: 30px; border-radius: 50%; opacity: 0.9; animation-duration: 22s; animation-delay: -4s; --initial-rotate: 0deg; --initial-radius: 50%; }

        /* Keyframes for gentle drifting and morphing */
        @keyframes move {
            0% { transform: translate(0, 0) scale(1) rotate(var(--initial-rotate, 0deg)); border-radius: var(--initial-radius, 50%); }
            50% { transform: translate(15px, 25px) scale(1.05) rotate(calc(var(--initial-rotate, 0deg) + 30deg)); border-radius: 40% 60% 60% 40% / 70% 50% 50% 30%; }
            100% { transform: translate(-10px, -20px) scale(0.95) rotate(calc(var(--initial-rotate, 0deg) - 20deg)); border-radius: var(--initial-radius, 50%); }
        }

         /* Glassmorphism Element Style (Widgets) - Uses mask */
        .glass-element {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            /* border-radius: 28px; */ /* Replaced by mask */
            position: relative;
            z-index: 1;
            margin-bottom: 15px;
            flex-shrink: 0;
            overflow: hidden; /* Needed for mask to clip content */
            /* Mask properties applied by JS */
            --widget-radius: 28px; /* Define CSS variable for radius */
        }
        .glass-element:last-child {
            margin-bottom: 0;
        }

        /* Spacer div */
        .spacer {
            flex-grow: 1;
        }

        /* App Icon Grid */
        .app-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px; /* Keep gap */
            position: relative;
            z-index: 1; /* Above background */
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        /* Individual App Icon Style - Uses mask */
        .app-icon {
            aspect-ratio: 1 / 1;
            background-color: rgba(245, 245, 245, 0.9);
            /* border-radius: 18px; */ /* Replaced by mask */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #374151; /* Default icon color */
            box-shadow: 0 3px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s ease-in-out;
            overflow: hidden; /* Needed for mask */
            cursor: pointer; /* Indicate clickable */
            position: relative; /* Needed for z-index */
            z-index: 2; /* Ensure icons are clickable above widgets */
            /* Mask properties applied by JS */
            --icon-radius: 18px; /* Define CSS variable for radius */
        }
        .app-icon:hover {
            transform: scale(1.05);
        }
        /* Explicit background/text colors using Tailwind classes in HTML */

        /* Middle Music Widget Style */
        .music-widget {
            padding: 15px;
            display: flex;
            align-items: center;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .music-widget img {
            width: 50px;
            height: 50px;
            border-radius: 10px; /* Keep simple radius for inner image */
            margin-right: 12px;
            object-fit: cover;
            background-color: rgba(255,255,255,0.2);
            flex-shrink: 0;
        }
        .music-info { flex-grow: 1; margin-right: 12px; overflow: hidden; }
        .music-info .title { font-weight: 600; font-size: 14px; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .music-info .artist { font-weight: 400; font-size: 12px; opacity: 0.8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .music-controls { flex-shrink: 0; }
        .music-controls button { background: none; border: none; color: #fff; font-size: 18px; padding: 5px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease; }
        .music-controls button:hover { opacity: 1; }
        .music-controls .play-pause { font-size: 22px; margin: 0 5px; }

        /* Weather Widget Style (Bottom) */
        .weather-widget {
            height: auto;
            padding: 18px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .widget-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;}
        .widget-location { font-size: 16px; font-weight: 600; }
        .widget-temp { font-size: 44px; font-weight: 700; line-height: 1; }
        .widget-condition { font-size: 14px; font-weight: 500; text-align: right; }
        .widget-icon { font-size: 26px; margin-bottom: 4px; }

        /* --- App Open Animation Styles --- */
        #app-open-overlay {
            position: fixed; /* Use fixed positioning relative to viewport */
            top: 0; /* Positioned via transform */
            left: 0; /* Positioned via transform */
            width: 0; /* Initial size set by JS */
            height: 0; /* Initial size set by JS */
            background-color: #ccc; /* Placeholder, will be set by JS */
            z-index: 1000; /* High z-index above everything */
            opacity: 0; /* Start transparent */
            transform-origin: top left; /* Consistent origin for transforms */
            /* Smooth transition for size, transform, opacity and mask */
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        mask-image 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        -webkit-mask-image 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            /* border-radius is handled by the mask */
            border-radius: 0; /* Keep at 0 */
            overflow: hidden; /* Needed for mask */
            display: none; /* Initially hidden */
            cursor: pointer; /* Indicate it's clickable to close */
            will-change: width, height, transform, opacity, mask-image, -webkit-mask-image; /* Optimize animation */
            /* Mask properties applied by JS */
        }

        #app-open-overlay.visible {
           display: block; /* Make it visible for animation */
           opacity: 1; /* Become opaque */
        }
        /* No closing class needed */

    </style>
</head>
<body>

    <div class="phone-frame">
        <div class="phone-screen">
            <div class="background-container">
                <div class="color-block block-1"></div>
                <div class="color-block block-2"></div>
                <div class="color-block block-3"></div>
                <div class="color-block block-4"></div>
                <div class="color-block block-5"></div>
            </div>

            <div class="spacer"></div>

            <div class="app-grid">
                 <div class="app-icon bg-green-500 text-white"><i class="fas fa-phone"></i></div>
                <div class="app-icon bg-blue-500 text-white"><i class="fas fa-comment-dots"></i></div>
                 <div class="app-icon bg-teal-500 text-white"><i class="fab fa-safari"></i></div>
                <div class="app-icon bg-red-500 text-white"><i class="fas fa-envelope"></i></div>
                 <div class="app-icon bg-yellow-500 text-white"><i class="fas fa-camera"></i></div>
                <div class="app-icon bg-purple-500 text-white"><i class="fas fa-music"></i></div>
                <div class="app-icon bg-orange-500 text-white"><i class="fas fa-map-marker-alt"></i></div>
                 <div class="app-icon bg-cyan-500 text-white"><i class="fas fa-calendar-alt"></i></div>
                 <div class="app-icon bg-pink-500 text-white"><i class="fas fa-heart"></i></div>
                 <div class="app-icon bg-lime-500 text-white"><i class="fas fa-play"></i></div>
                 <div class="app-icon bg-gray-200 text-gray-700"><i class="fas fa-cloud"></i></div>
                 <div class="app-icon bg-indigo-500 text-white"><i class="fas fa-cog"></i></div>
            </div>

            <div class="music-widget glass-element">
                 <img src="https://placehold.co/100x100/7b2cbf/white?text=Album" alt="Album Art" onerror="this.src='https://placehold.co/100x100/cccccc/ffffff?text=Error'">
                 <div class="music-info">
                     <div class="title">Sunset Drive</div>
                     <div class="artist">Lofi Chillhop</div>
                 </div>
                 <div class="music-controls">
                     <button aria-label="Previous Track"><i class="fas fa-backward-step"></i></button>
                     <button aria-label="Play/Pause" class="play-pause"><i class="fas fa-play"></i></button>
                     <button aria-label="Next Track"><i class="fas fa-forward-step"></i></button>
                 </div>
            </div>

            <div class="weather-widget glass-element">
                 <div class="widget-header">
                     <div>
                         <div class="widget-location">Taichung City</div>
                          <div class="widget-temp">28&deg;</div>
                     </div>
                     <div class="text-right">
                         <div class="widget-icon"><i class="fas fa-cloud-sun"></i></div>
                         <div class="widget-condition">Partly Cloudy</div>
                     </div>
                 </div>
            </div>

        </div>
    </div>
    <div id="app-open-overlay"></div>


    <script>
        // --- Constants for Radii (read from CSS variables or set directly) ---
        const ICON_RADIUS = '18px'; // Matches --icon-radius or the value used in applySquircleMask
        const PHONE_SCREEN_RADIUS = '60px'; // Matches --phone-screen-radius or the value used in applySquircleMask

        /**
         * Generates an SVG path string for a rounded rectangle with continuous curvature corners.
         * Uses a single cubic Bezier curve per corner, approximating a circular arc (kappa method).
         *
         * @param {number} W - The width of the rectangle.
         * @param {number} H - The height of the rectangle.
         * @param {number|string} r - The corner radius (can be px string or number).
         * @returns {string} The SVG path data string.
         */
        function generateContinuousPath(W, H, r) {
            // Convert radius string (like '18px') to number
            let radius = parseFloat(r);
            // Clamp radius
            radius = Math.min(radius, W / 2, H / 2);
            if (radius < 0) radius = 0;

            const k = 0.5522847498; // Kappa value for approximating circle with Bezier
            const ox = radius * k;
            const oy = radius * k;

            // Generate path data string
            const pathData = `
                M 0 ${radius}
                C 0 ${radius - oy}, ${radius - ox} 0, ${radius} 0
                L ${W - radius} 0
                C ${W - radius + ox} 0, ${W} ${radius - oy}, ${W} ${radius}
                L ${W} ${H - radius}
                C ${W} ${H - radius + oy}, ${W - radius + ox} ${H}, ${W - radius} ${H}
                L ${radius} ${H}
                C ${radius - ox} ${H}, 0 ${H - radius + oy}, 0 ${H - radius}
                Z
            `.replace(/\s+/g, ' ').trim(); // Clean up whitespace

            return pathData;
        }

        /**
         * Applies an SVG mask for continuous curvature corners to a given element.
         *
         * @param {Element} element - The DOM element to apply the mask to.
         * @param {number|string} radius - The desired corner radius (can be px string or number).
         * @param {number} [width] - Optional width for the mask (defaults to element's offsetWidth or bounding rect).
         * @param {number} [height] - Optional height for the mask (defaults to element's offsetHeight or bounding rect).
         */
        function applySquircleMask(element, radius, width, height) {
            if (!element) return; // Exit if element is null

            // Use provided dimensions or get from element's current state
            const rect = element.getBoundingClientRect();
            // Use provided W/H if > 0, otherwise use current element W/H
            // Prioritize offsetWidth/Height for more reliable layout dimensions including padding
            const W = width > 0 ? width : (element.offsetWidth > 0 ? element.offsetWidth : rect.width);
            const H = height > 0 ? height : (element.offsetHeight > 0 ? element.offsetHeight : rect.height);

            // Ensure we have valid dimensions before proceeding
            if (W <= 0 || H <= 0) {
                // Don't warn for overlay as its initial dimensions might be 0
                if(element.id !== 'app-open-overlay') {
                     console.warn('Skipping mask application for element with zero/invalid dimensions:', element, W, H);
                }
                return;
            }

            // Generate the SVG path for the mask
            const path = generateContinuousPath(W, H, radius);
            // Create the SVG mask string
            // Note: Using single quotes inside the SVG string for attributes
            const svgMask = `<svg xmlns='http://www.w3.org/2000/svg' width='${W}' height='${H}' viewBox='0 0 ${W} ${H}'><path d='${path}' fill='black'/></svg>`;
            // Encode the SVG string for use as a data URL
            const dataUrl = `url("data:image/svg+xml;utf8,${encodeURIComponent(svgMask)}")`;

            // Apply mask styles using vendor prefixes for compatibility
            element.style.webkitMaskImage = dataUrl;
            element.style.maskImage = dataUrl;
            element.style.webkitMaskSize = '100% 100%';
            element.style.maskSize = '100% 100%';
            element.style.webkitMaskRepeat = 'no-repeat';
            element.style.maskRepeat = 'no-repeat';
             // Important: Ensure the element clips its content to the mask shape
             element.style.webkitMaskComposite = 'source-in'; // For Webkit browsers
             element.style.maskComposite = 'intersect'; // Standard property
             // Ensure border-radius doesn't interfere
             element.style.borderRadius = '0';
        }

        /**
         * Removes the SVG mask from an element.
         * @param {Element} element - The DOM element to remove the mask from.
         */
        function removeSquircleMask(element) {
            if (!element) return;
            element.style.webkitMaskImage = 'none';
            element.style.maskImage = 'none';
        }


        // --- Apply Masks on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            const phoneFrame = document.querySelector('.phone-frame');
            const phoneScreen = document.querySelector('.phone-screen');
            const appIcons = document.querySelectorAll('.app-icon');
            const widgets = document.querySelectorAll('.glass-element');

             // Read radii from CSS variables if needed, otherwise use constants
             const phoneFrameRadius = '70px'; // Or read from CSS
             const phoneScreenRadius = PHONE_SCREEN_RADIUS; // Use constant
             const iconRadius = ICON_RADIUS; // Use constant
             const widgetRadius = '28px'; // Or read from CSS

            // Apply mask to Phone Frame
            if (phoneFrame) {
                applySquircleMask(phoneFrame, phoneFrameRadius);
            }

            // Apply mask to Phone Screen
            if (phoneScreen) {
                applySquircleMask(phoneScreen, phoneScreenRadius);
            }

            // Apply mask to App Icons
            appIcons.forEach(icon => {
                applySquircleMask(icon, iconRadius);
            });

            // Apply mask to Widgets
            widgets.forEach(widget => {
                 applySquircleMask(widget, widgetRadius);
            });

            // --- Initialize the App Open Animation Logic ---
            // Pass the phoneScreen element to the setup function
            if (phoneScreen) {
                setupAppOpenAnimation(phoneScreen);
            } else {
                console.error("Phone screen element not found!");
            }
        });

         // --- Optional: Re-apply masks on resize if layout is fluid ---
         let resizeTimeout;
         window.addEventListener('resize', () => {
             clearTimeout(resizeTimeout); // Clear previous timeout
             // Debounce the resize event
             resizeTimeout = setTimeout(() => {
                 console.log("Re-applying masks on resize");
                 const phoneFrame = document.querySelector('.phone-frame');
                 const phoneScreen = document.querySelector('.phone-screen');
                 const appIcons = document.querySelectorAll('.app-icon');
                 const widgets = document.querySelectorAll('.glass-element');
                 const overlay = document.getElementById('app-open-overlay'); // Also re-apply if visible

                 // Re-read radii in case they are dynamic
                 const phoneFrameRadius = '70px';
                 const phoneScreenRadius = PHONE_SCREEN_RADIUS;
                 const iconRadius = ICON_RADIUS;
                 const widgetRadius = '28px';

                 // Re-apply masks
                 if (phoneFrame) applySquircleMask(phoneFrame, phoneFrameRadius);
                 if (phoneScreen) applySquircleMask(phoneScreen, phoneScreenRadius);
                 appIcons.forEach(icon => applySquircleMask(icon, iconRadius));
                 widgets.forEach(widget => applySquircleMask(widget, widgetRadius));

                 // If overlay is currently displayed (expanded), re-apply its mask
                 // AND update its position/size if the screen resized
                 if (overlay && overlay.style.display === 'block' && overlay.classList.contains('visible')) {
                    const phoneScreenRect = phoneScreen?.getBoundingClientRect();
                    const screenWidth = phoneScreen?.offsetWidth;
                    const screenHeight = phoneScreen?.offsetHeight;
                    if (phoneScreenRect && screenWidth && screenHeight) {
                         // Update size and position to match the new screen dimensions
                         overlay.style.width = `${screenWidth}px`;
                         overlay.style.height = `${screenHeight}px`;
                         overlay.style.transform = `translate(${phoneScreenRect.left}px, ${phoneScreenRect.top}px)`;
                         // Re-apply the mask with the correct (potentially new) dimensions
                         applySquircleMask(overlay, phoneScreenRadius, screenWidth, screenHeight);
                    }
                 }


             }, 150); // Wait 150ms after resize stops
         });

         // --- App Open Animation Logic ---
        /**
         * Sets up the click listeners and animation logic for app icons.
         * @param {Element} phoneScreenElement - The DOM element representing the phone screen.
         */
        function setupAppOpenAnimation(phoneScreenElement) {
            const icons = document.querySelectorAll('.app-icon');
            const overlay = document.getElementById('app-open-overlay');
            if (!overlay) {
                console.error("Overlay element not found!");
                return;
            }

            let currentIcon = null; // Track the originating icon
            let isAnimating = false; // Track animation state
            let animationDirection = null; // 'opening' or 'closing'
            let lastIconRect = null; // Store icon rect for closing

            // Define named functions for event listeners to allow removal
            const openTransitionEndHandler = (event) => {
                // Check if the transition ended for a property we care about (e.g., transform or width)
                if (['transform', 'width', 'height'].includes(event.propertyName)) {
                    // Only set isAnimating to false once *all* tracked properties have finished transitioning
                    // This simple check might need refinement if transitions have different durations/delays
                    isAnimating = false;
                    animationDirection = null;
                    overlay.removeEventListener('transitionend', openTransitionEndHandler);
                    console.log("Open transition finished for:", event.propertyName);
                }
            };

            const closeTransitionEndHandler = (event) => {
                 if (['transform', 'width', 'height'].includes(event.propertyName)) {
                    // Wait for transform/width/height to finish before hiding
                    isAnimating = false;
                    animationDirection = null;
                    overlay.style.display = 'none'; // Hide the element
                    overlay.classList.remove('visible'); // Remove visibility class
                    removeSquircleMask(overlay); // Clean up mask
                    currentIcon = null; // Reset the tracked icon
                    lastIconRect = null;
                    overlay.removeEventListener('transitionend', closeTransitionEndHandler);
                    overlay.removeEventListener('click', closeOverlay); // Remove close listener
                    console.log("Close transition finished for:", event.propertyName);
                 }
            };

            // --- Function to close the overlay ---
            function closeOverlay() {
                if (!currentIcon || !lastIconRect) {
                    console.log("Close cancelled: Missing icon or screen data");
                    return;
                }
                if (isAnimating && animationDirection === 'closing') return;

                console.log("Closing animation triggered");
                isAnimating = true;
                animationDirection = 'closing';

                // Remove any existing transitionend listeners
                overlay.removeEventListener('transitionend', openTransitionEndHandler);
                overlay.removeEventListener('transitionend', closeTransitionEndHandler);

                // Apply the icon mask *immediately* using stored icon dimensions
                applySquircleMask(overlay, ICON_RADIUS, lastIconRect.width, lastIconRect.height);

                // Apply styles for the shrinking animation:
                // Animate back to the icon's original position and size
                overlay.style.width = `${lastIconRect.width}px`;
                overlay.style.height = `${lastIconRect.height}px`;
                overlay.style.transform = `translate(${lastIconRect.left}px, ${lastIconRect.top}px)`;
                overlay.style.opacity = '0'; // Fade out

                // Add the listener for when the closing animation finishes
                overlay.addEventListener('transitionend', closeTransitionEndHandler);
            }

            // --- Add click listener to each app icon ---
            icons.forEach(icon => {
                icon.addEventListener('click', (e) => {
                    if (isAnimating) return; // Prevent starting new animation if one is running

                    console.log("Opening animation triggered");
                    isAnimating = true;
                    animationDirection = 'opening';
                    currentIcon = e.currentTarget; // Store the clicked icon element
                    const iconRect = currentIcon.getBoundingClientRect(); // Get icon position/size (relative to viewport)
                    const phoneScreenRect = phoneScreenElement.getBoundingClientRect(); // Get phone screen position/size (for positioning)
                    const phoneScreenOffsetWidth = phoneScreenElement.offsetWidth; // Get screen layout width (for target size/mask)
                    const phoneScreenOffsetHeight = phoneScreenElement.offsetHeight; // Get screen layout height (for target size/mask)
                    const iconColor = window.getComputedStyle(currentIcon).backgroundColor; // Get icon color

                    // Store icon rect for closing animation
                    lastIconRect = iconRect;

                    // Remove any existing transitionend listeners before starting
                    overlay.removeEventListener('transitionend', openTransitionEndHandler);
                    overlay.removeEventListener('transitionend', closeTransitionEndHandler);

                    // 1. Set initial state of the overlay (at icon's position and size)
                    overlay.style.backgroundColor = iconColor;
                    overlay.style.width = `${iconRect.width}px`; // Use icon's actual width
                    overlay.style.height = `${iconRect.height}px`; // Use icon's actual height
                    // Apply initial transform to place it over the icon
                    overlay.style.transform = `translate(${iconRect.left}px, ${iconRect.top}px)`;
                    overlay.style.opacity = '1'; // Start fully visible
                    overlay.style.display = 'block'; // Make it visible
                    overlay.style.transformOrigin = 'top left'; // Keep origin consistent

                    // Apply icon mask initially using icon dimensions
                    applySquircleMask(overlay, ICON_RADIUS, iconRect.width, iconRect.height);

                    // Add the visible class (doesn't trigger transition yet)
                    overlay.classList.add('visible');

                    // 2. Force reflow: Ensure browser applies initial styles BEFORE starting transition
                    void overlay.offsetWidth;

                    // 3. Set target state (filling phone screen)
                    // Apply the phone screen mask *immediately* using target dimensions
                    applySquircleMask(overlay, PHONE_SCREEN_RADIUS, phoneScreenOffsetWidth, phoneScreenOffsetHeight);

                    // Set the target size and position
                    overlay.style.width = `${phoneScreenOffsetWidth}px`;
                    overlay.style.height = `${phoneScreenOffsetHeight}px`;
                    overlay.style.transform = `translate(${phoneScreenRect.left}px, ${phoneScreenRect.top}px)`;

                    // Add the listener for when the opening animation finishes
                    overlay.addEventListener('transitionend', openTransitionEndHandler);

                    // Add click listener to the overlay itself to trigger the close animation
                    overlay.removeEventListener('click', closeOverlay);
                    overlay.addEventListener('click', closeOverlay);
                });
            });
        }

    </script>

</body>
</html>
