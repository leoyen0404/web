<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>線性代數期中考重點筆記</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMQNogNje1PeHzc4ECPpuLoBVLPCoUPfnlOCrBrowser" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlVwcpaN8sdkXyzAEP7Cstream5StQPsJqk78vynAHzUWCIy8jEpa9DQAmd9W" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>

    <!-- Google Fonts: Inter & Noto Sans TC -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #0d1224;
            --grid-color: rgba(56, 189, 248, 0.1);
            --card-bg-color: rgba(22, 28, 53, 0.5);
            --border-color: rgba(56, 189, 248, 0.2);
            --border-hover-color: rgba(56, 189, 248, 0.5);
            --text-primary: #f0f8ff;
            --text-secondary: #94a3b8;
            --accent-color: #0ea5e9;
            --accent-glow: rgba(14, 165, 233, 0.3);
            --font-size-base: 16px;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 1.875rem;
            --font-size-display: 4.5rem;
            --spacing-unit: 8px;
            --transition-curve: cubic-bezier(0.16, 1, 0.3, 1);
            --transition-duration: 0.5s;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-size: var(--font-size-base);
            overflow-x: hidden;
            cursor: none;
        }
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.1); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.2); }
        .parallax-container { height: 100vh; overflow-x: hidden; overflow-y: auto; perspective: 10px; -webkit-overflow-scrolling: touch; }
        .parallax-layer { position: absolute; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none; }
        .layer-mid { transform: translateZ(-10px) scale(2); }
        .layer-fg { transform: translateZ(0) scale(1); pointer-events: auto; user-select: text; -webkit-user-select: text; }
        .background-grid {
            width: 100%; height: 500%;
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px);
            background-size: 60px 60px;
            transition: background-position 0.1s linear;
        }
        .content-grid { display: grid; grid-template-columns: 1fr min(80ch, calc(100% - 64px)) 1fr; grid-column-gap: 32px; padding: 0 32px; width: 100%; }
        .content-grid > * { grid-column: 2; }
        .full-bleed { grid-column: 1 / -1; width: 100%; }
        .main-header { height: 100vh; display: flex; align-items: center; justify-content: center; text-align: center; position: relative; z-index: 2; }
        .main-header h1 { font-size: var(--font-size-display); font-weight: 700; letter-spacing: -0.05em; background: linear-gradient(120deg, var(--text-primary) 50%, var(--text-secondary) 100%); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .main-header p { font-size: var(--font-size-xl); color: var(--text-secondary); }
        .glass-card { background: var(--card-bg-color); backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px); border: 1px solid var(--border-color); transition: transform var(--transition-duration) var(--transition-curve), border-color var(--transition-duration) var(--transition-curve); border-radius: 24px; overflow: hidden; position: relative; }
        .glass-card:hover { border-color: var(--border-hover-color); transform: translateY(-4px); }
        .glass-card::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(400px circle at var(--mouse-x) var(--mouse-y), rgba(14, 165, 233, 0.1), transparent 80%); opacity: 0; transition: opacity 0.5s; will-change: opacity; }
        .glass-card:hover::before { opacity: 1; }
        .card-content { padding: calc(var(--spacing-unit) * 4); }
        .section-title { font-size: var(--font-size-3xl); font-weight: 600; margin-bottom: calc(var(--spacing-unit) * 6); margin-top: calc(var(--spacing-unit) * 12); position: relative; padding-bottom: var(--spacing-unit); }
        .section-title::after { content: ''; position: absolute; left: 0; bottom: 0; width: 48px; height: 2px; background: var(--accent-color); }
        .content-block h3 { font-size: var(--font-size-xl); font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-unit); }
        .content-block p, .content-block ul, .content-block ol { font-size: var(--font-size-base); line-height: 1.8; color: var(--text-secondary); }
        .content-block ul { list-style-position: inside; padding-left: 1rem; }
        .content-block ol { list-style-type: decimal; list-style-position: inside; }
        .content-block code { background: rgba(14, 165, 233, 0.1); color: var(--accent-color); padding: 0.2em 0.4em; border-radius: 6px; font-family: monospace; }
        .katex-display { padding: calc(var(--spacing-unit) * 2); background: rgba(0, 0, 0, 0.2); border-radius: 12px; overflow-x: auto; margin: calc(var(--spacing-unit) * 2) 0; border: 1px solid rgba(255,255,255,0.05); }
        .site-footer { padding: calc(var(--spacing-unit) * 8) 0; text-align: center; color: var(--text-secondary); font-size: 0.875rem; }
        .highlight { color: var(--accent-color); font-weight: bold; }
        .scroll-animated { opacity: 0; transform: translate3d(0, 40px, 0) scale(0.98); transition: opacity 0.8s var(--transition-curve), transform 0.8s var(--transition-curve); will-change: opacity, transform; }
        .scroll-animated.is-visible { opacity: 1; transform: translate3d(0, 0, 0) scale(1); }
        .scroll-animated.staggered { transition-delay: calc(0.15s * var(--stagger-index)); }
        #custom-cursor { position: fixed; top: 0; left: 0; width: 50px; height: 50px; pointer-events: none; z-index: 9999; will-change: transform; }
        #cursor-path { stroke: rgba(56, 189, 248, 0.7); stroke-width: 2; fill: none; transform-origin: 25px 25px; }
        .scroll-progress-container { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%); width: 200px; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; z-index: 100; }
        #scroll-progress-bar { width: 0; height: 100%; background: var(--accent-color); border-radius: 2px; transition: width 0.1s linear; }
    </style>
</head>
<body>
    
    <svg id="custom-cursor">
        <path id="cursor-path" d=""></path>
    </svg>

    <div class="parallax-container">
        
        <div class="parallax-layer layer-mid">
            <div class="background-grid"></div>
        </div>
        
        <div class="parallax-layer layer-fg">
            <main class="content-grid">

                <header class="main-header full-bleed scroll-animated">
                    <div>
                        <h1>線性代數期中考重點筆記</h1>
                        <p>CH2 行列式 & CH3 向量空間高分攻略</p>
                    </div>
                </header>

                <!-- CH1 Review Section -->
                <section class="scroll-animated">
                    <h2 class="section-title">CH1 核心回顧</h2>
                    <div class="space-y-8">
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 1;">
                            <div class="card-content content-block">
                                <h3>矩陣運算與性質</h3>
                                <p>CH1 的基礎運算一定要熟練，它們是後續章節的基石。</p>
                                <ul>
                                    <li><b>矩陣乘法:</b> $A_{m \times r} B_{r \times n} = C_{m \times n}$，前矩陣的行數需等於後矩陣的列數。$(AB)C = A(BC)$ 結合律成立，但 $AB \neq BA$ 交換律通常不成立。</li>
                                    <li><b>反矩陣 (Inverse):</b> 只有方陣才可能可逆。若 $AB = BA = I$，則 $B$ 是 $A$ 的反矩陣，記作 $A^{-1}$。重要性質：$(AB)^{-1} = B^{-1}A^{-1}$。</li>
                                    <li><b>轉置矩陣 (Transpose):</b> 將矩陣的行與列交換，記作 $A^T$。重要性質：$(AB)^T = B^T A^T$。</li>
                                </ul>
                            </div>
                        </div>
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 2;">
                             <div class="card-content content-block">
                                <h3>可逆矩陣等價定理 (超重要)</h3>
                                <p>這個定理串連了整個線性代數前半的關鍵概念。對於一個 $n \times n$ 的方陣 $A$，以下敘述是等價的 (全部成立或全部不成立)：</p>
                                <ul>
                                    <li>(a) $A$ 是可逆的 (invertible)。</li>
                                    <li>(b) 線性系統 $Ax = 0$ 只有唯一解 (顯解 $x=0$)。</li>
                                    <li>(c) $A$ 的簡化列梯形 (RREF) 是單位矩陣 $I_n$。</li>
                                    <li>(d) 對於任何 $n \times 1$ 的向量 $b$，$Ax = b$ 都有唯一解。</li>
                                    <li><b class="highlight">(g) $\det(A) \neq 0$ (這是 CH2 的核心關聯)。</b></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- CH2 Determinants Section -->
                <section class="scroll-animated">
                    <h2 class="section-title">CH2 行列式 (Determinants) - 考試重點</h2>
                    <div class="space-y-8">
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 1;">
                            <div class="card-content content-block">
                                <h3><span class="highlight">[考古題重點]</span> 計算方法 (一)：高斯消去法</h3>
                                <p>這是計算行列式值的最主要方法，考古題計算大題必考。目標是將矩陣化為上三角矩陣 (列梯形)，行列式值即為主對角線元素乘積。過程中需注意列運算對行列式值的影響：</p>
                                <ul>
                                    <li>1. <b>某列乘以 $k$ 倍:</b> 行列式值要提出 $k$ 倍。 $\det(B) = k \det(A)$。</li>
                                    <li>2. <b>交換兩列:</b> 行列式值要變號。 $\det(B) = -\det(A)$。</li>
                                    <li>3. <b>某列的倍數加到另一列:</b> 行列式值<b>不變</b>。 $\det(B) = \det(A)$。</li>
                                </ul>
                                <p><b>解題策略：</b>透過操作 (3) 製造零，配合操作 (1), (2) 簡化計算，最終化為三角矩陣求解。</p>
                            </div>
                        </div>
                                 <div class="glass-card scroll-animated staggered" style="--stagger-index: 2;">
                                     <div class="card-content content-block">
                                <h3><span class="highlight">[考古題重点]</span> 行列式重要性質 (選擇/填充熱門考點)</h3>
                                <p>這些性質是選擇題和填充題的重點，務必記熟！假設 $A, B$ 是 $n \times n$ 方陣，$k$ 是純量:</p>
                                <ul>
                                    <li>$\det(A) \neq 0 \iff A$ 可逆。</li>
                                    <li>$\det(AB) = \det(A)\det(B)$。</li>
                                    <li>$\det(kA) = k^n \det(A)$ (注意是 $n$ 次方)。</li>
                                    <li>若 $A$ 可逆, $\det(A^{-1}) = \frac{1}{\det(A)}$。</li>
                                    <li>$\det(A^T) = \det(A)$ (列的性質對行也適用)。</li>
                                    <li>若 $A$ 有一整行或一整列為零，則 $\det(A) = 0$。</li>
                                    <li>若 $A$ 有兩行或兩列成比例(或相同)，則 $\det(A) = 0$。</li>
                                    <li>三角矩陣的行列式值 = 對角線元素乘積。</li>
                                </ul>
                            </div>
                        </div>
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 3;">
                             <div class="card-content content-block">
                                <h3><span class="highlight">[考古題重点]</span> 伴隨矩陣與反矩陣公式</h3>
                                <p>這個公式將行列式值與反矩陣直接聯繫起來。</p>
                                <p><b>餘因子 (Cofactor):</b> $C_{ij} = (-1)^{i+j}M_{ij}$，其中 $M_{ij}$ 是刪除第i列、第j行後的子行列式值。</p>
                                <p><b>伴隨矩陣 (Adjoint Matrix):</b> 先計算所有元素的餘因子，形成餘因子矩陣 $C$。$A$ 的伴隨矩陣是 $C$ 的轉置，即 $\text{adj}(A) = C^T$。</p>
                                <p><b>反矩陣公式:</b></p>
                                <div class="katex-display">$$A^{-1} = \frac{1}{\det(A)}\text{adj}(A)$$</div>
                                <p><b>考古題提示：</b>考試可能會要求你計算伴隨矩陣的某一行或某一列，你只需要計算對應的餘因子即可，不必算出整個矩陣。</p>
                            </div>
                        </div>
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 4;">
                             <div class="card-content content-block">
                                <h3><span class="highlight">[考古題重点]</span> 克拉馬法則 (Cramer's Rule)</h3>
                                <p>當 $A$ 為可逆方陣時，提供了一個求解線性系統 $Ax=b$ 的公式解，適合求解單一未知數。</p>
                                <p><b>公式:</b> 系統的解為</p>
                                <div class="katex-display">$$x_j = \frac{\det(A_j)}{\det(A)}$$</div>
                                <p>其中 $A_j$ 是將 $A$ 矩陣的第 $j$ 行用向量 $b$ 替換後得到的新矩陣。</p>
                                <p><b>考古題提示：</b>通常要求「列式即可」，代表你必須寫出公式中分子和分母的行列式，不一定需要完整算出數值。</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- CH3 Vectors Section -->
                <section class="scroll-animated">
                    <h2 class="section-title">CH3 歐幾里得向量空間 - 考試重點</h2>
                    <div class="space-y-8">
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 1;">
                            <div class="card-content content-block">
                                <h3>向量的模、距離與點積</h3>
                                <p>這是本章的基礎計算。令 $\mathbf{u}=(u_1, ..., u_n), \mathbf{v}=(v_1, ..., v_n)$。</p>
                                <ul>
                                    <li><b>模 (Norm):</b> 向量的長度。</li>
                                    <div class="katex-display">$$\lVert\mathbf{u}\rVert = \sqrt{u_1^2 + u_2^2 + \dots + u_n^2}$$</div>
                                    <li><b>距離 (Distance):</b> 兩向量終點的距離。</li>
                                    <div class="katex-display">$$d(\mathbf{u}, \mathbf{v}) = \lVert\mathbf{u} - \mathbf{v}\rVert = \sqrt{(u_1-v_1)^2 + \dots + (u_n-v_n)^2}$$</div>
                                    <li><b>點積 (Dot Product):</b> 有兩種定義方式，都非常重要。</li>
                                    <div class="katex-display">$$\text{代數定義: } \mathbf{u} \cdot \mathbf{v} = u_1v_1 + u_2v_2 + \dots + u_nv_n$$</div>
                                    <div class="katex-display">$$\text{幾何定義: } \mathbf{u} \cdot \mathbf{v} = \lVert\mathbf{u}\rVert \, \lVert\mathbf{v}\rVert \cos\theta$$</div>
                                </ul>
                            </div>
                        </div>
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 2;">
                            <div class="card-content content-block">
                                <h3><span class="highlight">[考古題重点]</span> 正交性與正交投影</h3>
                                <p>這是本章的應用核心，考古題計算大題的熱門選項。</p>
                                <p><b>正交 (Orthogonal):</b> 兩向量垂直，若且唯若它們的點積為零。</p>
                                <div class="katex-display">$$\mathbf{u} \perp \mathbf{v} \\iff \mathbf{u} \cdot \mathbf{v} = 0$$</div>
                                <p><b>正交投影 (Orthogonal Projection):</b> 將向量 $\mathbf{u}$ 投影到向量 $\mathbf{a}$ 上的分量向量是</p>
                                <div class="katex-display">$$\operatorname{proj}_{\mathbf{a}}\mathbf{u} = \frac{\mathbf{u} \cdot \mathbf{a}}{\lVert\mathbf{a}\rVert^2}\mathbf{a}$$</div>
                                <p>而 $\mathbf{u}$ 正交於 $\mathbf{a}$ 的分量向量是</p>
                                <div class="katex-display">$$\mathbf{u} - \operatorname{proj}_{\mathbf{a}}\mathbf{u}$$</div>
                            </div>
                        </div>
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 3;">
                            <div class="card-content content-block">
                                <h3><span class="highlight">[考古題重点]</span> 重要不等式與恆等式</h3>
                                <p>這些是填充題的常客，需要能夠寫出公式。</p>
                                <ul>
                                    <li><b>向量夾角公式:</b></li>
                                    <div class="katex-display">$$\cos\theta = \frac{\mathbf{u} \cdot \mathbf{v}}{\lVert\mathbf{u}\rVert \, \lVert\mathbf{v}\rVert}$$</div>
                                    <li><b>柯西-史瓦茲不等式 (Cauchy-Schwarz Inequality):</b></li>
                                    <div class="katex-display">$$|\mathbf{u} \cdot \mathbf{v}| \le \lVert\mathbf{u}\rVert \, \lVert\mathbf{v}\rVert$$</div>
                                    <li><b>三角不等式 (Triangle Inequality):</b></li>
                                    <div class="katex-display">$$\lVert\mathbf{u} + \mathbf{v}\rVert \le \lVert\mathbf{u}\rVert + \lVert\mathbf{v}\rVert$$</div>
                                    <li><b>平行四邊形恆等式相關:</b> 點積與模的關係</li>
                                    <div class="katex-display">$$\lVert\mathbf{u}+\mathbf{v}\rVert^2 = \lVert\mathbf{u}\rVert^2 + \lVert\mathbf{v}\rVert^2 + 2(\mathbf{u} \cdot \mathbf{v})$$</div>
                                    <div class="katex-display">$$\lVert\mathbf{u}-\mathbf{v}\rVert^2 = \lVert\mathbf{u}\rVert^2 + \lVert\mathbf{v}\rVert^2 - 2(\mathbf{u} \cdot \mathbf{v})$$</div>
                                    <p>由上面兩式相減可得考古題中的恆等式：</p>
                                    <div class="katex-display">$$\lVert\mathbf{u}+\mathbf{v}\rVert^2 - \lVert\mathbf{u}-\mathbf{v}\rVert^2 = 4(\mathbf{u} \cdot \mathbf{v})$$</div>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Practice Problems Section -->
                <section class="scroll-animated">
                    <h2 class="section-title">考古題演練</h2>
                    <div class="space-y-8">
                        
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 1;">
                            <div class="card-content content-block">
                                <h3>Q1: 利用高斯消去法求行列式值 (20%)</h3>
                                <p>求 $A = \begin{pmatrix} 0 & 1 & 5 \\ 3 & -6 & 9 \\ 2 & 6 & 1 \end{pmatrix}$ 的行列式值。</p>
                                <p><b>解題思路:</b> 透過列運算將矩陣化為上三角形式，並記錄過程中對行列式值的影響。</p>
                                <div class="katex-display">$$
                                \begin{aligned}
                                \det(A) &= \begin{vmatrix} 0 & 1 & 5 \\ 3 & -6 & 9 \\ 2 & 6 & 1 \end{vmatrix} \\
                                &= - \begin{vmatrix} 3 & -6 & 9 \\ 0 & 1 & 5 \\ 2 & 6 & 1 \end{vmatrix} & (\text{交換 R1, R2}) \\
                                &= -3 \begin{vmatrix} 1 & -2 & 3 \\ 0 & 1 & 5 \\ 2 & 6 & 1 \end{vmatrix} & (\text{從 R1 提出 3}) \\
                                &= -3 \begin{vmatrix} 1 & -2 & 3 \\ 0 & 1 & 5 \\ 0 & 10 & -5 \end{vmatrix} & (R3 - 2R1 \to R3) \\
                                &= -3 \begin{vmatrix} 1 & -2 & 3 \\ 0 & 1 & 5 \\ 0 & 0 & -55 \end{vmatrix} & (R3 - 10R2 \to R3) \\
                                &= -3 \times (1) \times (1) \times (-55) \\
                                &= 165
                                \end{aligned}
                                $$</div>
                            </div>
                        </div>
                        
                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 2;">
                            <div class="card-content content-block">
                                <h3>Q2: 求伴隨矩陣的第三列 (12%)</h3>
                                <p>求 $A = \begin{pmatrix} 3 & 2 & -1 \\ 1 & 6 & 3 \\ 2 & -4 & 0 \end{pmatrix}$ 的伴隨矩陣的第三列 (3rd row)。</p>
                                <p><b>解題思路:</b> 伴隨矩陣 $\text{adj}(A)$ 是餘因子矩陣 $C$ 的轉置。所以 $\text{adj}(A)$ 的第三列就是 $C$ 的第三行，也就是 $C_{13}, C_{23}, C_{33}$。</p>
                                <ul>
                                    <li>$C_{13} = (-1)^{1+3} \begin{vmatrix} 1 & 6 \\ 2 & -4 \end{vmatrix} = 1 \cdot (-4 - 12) = -16$</li>
                                    <li>$C_{23} = (-1)^{2+3} \begin{vmatrix} 3 & 2 \\ 2 & -4 \end{vmatrix} = -1 \cdot (-12 - 4) = 16$</li>
                                    <li>$C_{33} = (-1)^{3+3} \begin{vmatrix} 3 & 2 \\ 1 & 6 \end{vmatrix} = 1 \cdot (18 - 2) = 16$</li>
                                </ul>
                                <p>所以，伴隨矩陣的第三列是 $(-16, 16, 16)$。</p>
                            </div>
                        </div>

                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 3;">
                            <div class="card-content content-block">
                                <h3>Q4: 正交投影 (13%)</h3>
                                <p>令 $\mathbf{u} = (2, -1, 3)$ 及 $\mathbf{a} = (4, -1, 2)$，試求 $\mathbf{u}$ 在 $\mathbf{a}$ 上的分量向量 (投影) 與正交於 $\mathbf{a}$ 的分量向量。</p>
                                <p><b>解題思路:</b> 直接代入正交投影的公式。</p>
                                <p>1. <b>計算點積與模的平方:</b></p>
                                <div class="katex-display">$$\mathbf{u} \cdot \mathbf{a} = (2)(4) + (-1)(-1) + (3)(2) = 15$$</div>
                                <div class="katex-display">$$\lVert\mathbf{a}\rVert^2 = 4^2 + (-1)^2 + 2^2 = 21$$</div>
                                <p>2. <b>計算投影向量 $\mathbf{w}_1$:</b></p>
                                <div class="katex-display">$$
                                \mathbf{w}_1 = \operatorname{proj}_{\mathbf{a}}\mathbf{u} = \frac{\mathbf{u} \cdot \mathbf{a}}{\lVert\mathbf{a}\rVert^2}\mathbf{a} = \frac{15}{21}(4, -1, 2) = \frac{5}{7}(4, -1, 2) = \left(\tfrac{20}{7}, -\tfrac{5}{7}, \tfrac{10}{7}\right)
                                $$</div>
                                <p>3. <b>計算正交分量 $\mathbf{w}_2$:</b></p>
                                <div class="katex-display">$$
                                \begin{aligned}
                                \mathbf{w}_2 &= \mathbf{u} - \mathbf{w}_1 \\
                                &= (2, -1, 3) - \left(\tfrac{20}{7}, -\tfrac{5}{7}, \tfrac{10}{7}\right) \\
                                &= \left(-\tfrac{6}{7}, -\tfrac{2}{7}, \tfrac{11}{7}\right)
                                \end{aligned}
                                $$</div>
                            </div>
                        </div>

                        <div class="glass-card scroll-animated staggered" style="--stagger-index: 4;">
                            <div class="card-content content-block">
                                <h3>Q6: 填充/簡答題集錦 (25%)</h3>
                                <p>這些題目考驗你對核心公式的熟悉度。</p>
                                <ol>
                                    <li><b>u=(3,4,5) 在 i=(1,0,0) 上的投影向量:</b><br>
                                    $\text{proj}_{\mathbf{i}}\mathbf{u} = \frac{\mathbf{u} \cdot \mathbf{i}}{||\mathbf{i}||^2}\mathbf{i} = \frac{3}{1^2}(1,0,0) = (3,0,0)$<br>
                                    <b>正交分量:</b> $\mathbf{u} - \text{proj}_{\mathbf{i}}\mathbf{u} = (3,4,5) - (3,0,0) = (0,4,5)$
                                    </li>
                                    <li><b>三角不等式:</b> $d(\mathbf{u}, \mathbf{v}) \le d(\mathbf{u}, \mathbf{w}) + d(\mathbf{w}, \mathbf{v})$</li>
                                    <li><b>柯西-史瓦茲不等式:</b> $|\mathbf{u} \cdot \mathbf{v}| \le ||\mathbf{u}|| \ ||\mathbf{v}||$</li>
                                    <li><b>恆等式:</b> $||\mathbf{u}+\mathbf{v}||^2 - ||\mathbf{u}-\mathbf{v}||^2 = 4(\mathbf{u} \cdot \mathbf{v})$</li>
                                    <li><b>u=(1,1,1) 與 k=(0,0,1) 的夾角餘弦:</b><br>
                                    $\cos\theta = \frac{\mathbf{u} \cdot \mathbf{k}}{||\mathbf{u}|| ||\mathbf{k}||} = \frac{1}{\sqrt{1^2+1^2+1^2} \cdot \sqrt{1^2}} = \frac{1}{\sqrt{3}}$</li>
                                </ol>
                            </div>
                        </div>

                    </div>
                </section>
                
                <footer class="site-footer full-bleed scroll-animated">
                    <p>祝您考試順利！</p>
                </footer>

            </main>
        </div>
    </div>

    <div class="scroll-progress-container">
        <div id="scroll-progress-bar"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector('.parallax-container');
            const progressBar = document.getElementById('scroll-progress-bar');
            const grid = document.querySelector('.background-grid');

            const mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            container.addEventListener('mousemove', (e) => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });

            const updateGridPosition = () => {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const mouseOffsetX = (mouse.x - centerX) * 0.05;
                const mouseOffsetY = (mouse.y - centerY) * 0.05;
                const scrollOffsetY = container.scrollTop * 0.2;
                const totalOffsetX = -mouseOffsetX;
                const totalOffsetY = -mouseOffsetY - scrollOffsetY;
                grid.style.backgroundPosition = `${totalOffsetX}px ${totalOffsetY}px`;
                requestAnimationFrame(updateGridPosition);
            };
            requestAnimationFrame(updateGridPosition);

            const updateProgress = () => {
                const scrollableHeight = container.scrollHeight - container.clientHeight;
                const progress = scrollableHeight > 0 ? (container.scrollTop / scrollableHeight) * 100 : 0;
                progressBar.style.width = `${progress}%`;
            };
            container.addEventListener('scroll', updateProgress);
            updateProgress();

            document.querySelectorAll('.glass-card').forEach(card => {
                card.addEventListener('mousemove', (e) => {
                    const rect = card.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    card.style.setProperty('--mouse-x', `${x}px`);
                    card.style.setProperty('--mouse-y', `${y}px`);
                });
            });

            const animatedElements = document.querySelectorAll('.scroll-animated');
            const observer = new IntersectionObserver((entries, obs) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting || entry.intersectionRatio > 0) {
                        entry.target.classList.add('is-visible');
                        obs.unobserve(entry.target);
                    }
                });
            }, { root: container, threshold: [0, 0.1, 0.25], rootMargin: '0px' });
            animatedElements.forEach(el => observer.observe(el));

            animatedElements.forEach(el => {
                if (el.getBoundingClientRect().top < window.innerHeight) {
                    el.classList.add('is-visible');
                    observer.unobserve(el);
                }
            });

            const cursorSvg = document.getElementById('custom-cursor');
            const cursorPath = document.getElementById('cursor-path');

            const hoverSelector = [
                'h1','h2','h3','h4','h5','h6',
                'p','li','a','button','label','span','code','blockquote','strong',
                '.glass-card','.glass-card *',
                '.katex','.katex *'
            ].join(', ');
            const registeredHoverElements = new WeakSet();

            const cursorMouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            const cursorState = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            const speed = 0.15;

            let targetN = 0.1, currentN = 0.1, velocityN = 0;
            let targetSize = 8, currentSize = 8, velocitySize = 0;
            let targetFillOpacity = 0, currentFillOpacity = 0, velocityFillOpacity = 0;
            let targetRotation = 0, currentRotation = 0, velocityRotation = 0;
            let targetStretch = 1, currentStretch = 1, velocityStretch = 0;

            const stiffness = 0.15, damping = 0.25;
            const rotationStiffness = 0.1, rotationDamping = 0.5;

            let isMouseDown = false;
            let isHoveringText = false;
            let currentHoverTarget = null;

            window.addEventListener('mousemove', (e) => {
                cursorMouse.x = e.clientX;
                cursorMouse.y = e.clientY;
            });

            window.addEventListener('mousedown', () => {
                isMouseDown = true;
                targetN = 2.0;
                if (!isHoveringText) {
                    targetSize = 8;
                }
                targetFillOpacity = 0.2;
            });

            window.addEventListener('mouseup', () => {
                isMouseDown = false;
                targetN = isHoveringText ? 8.0 : 0.1;
                const fontSize = isHoveringText ? parseFloat(getComputedStyle(currentHoverTarget).fontSize) : 0;
                targetSize = isHoveringText ? Math.min(12 + fontSize * 0.4, 24.5) : 8;
                targetFillOpacity = 0;
            });

            const attachHoverListeners = () => {
                document.querySelectorAll(hoverSelector).forEach(el => {
                    if (registeredHoverElements.has(el)) return;
                    registeredHoverElements.add(el);
                    el.addEventListener('mouseenter', (e) => {
                        isHoveringText = true;
                        currentHoverTarget = e.target;
                        if (!isMouseDown) {
                            targetN = 8.0;
                            const fontSize = parseFloat(getComputedStyle(e.target).fontSize) || 16;
                            targetSize = Math.min(12 + fontSize * 0.4, 24.5);
                        }
                    });
                    el.addEventListener('mouseleave', () => {
                        isHoveringText = false;
                        currentHoverTarget = null;
                        if (!isMouseDown) {
                            targetN = 0.1;
                            targetSize = 8;
                        }
                    });
                });
            };
            attachHoverListeners();

            function generateSuperellipsePath(a, b, n, rotationDegrees, points = 100) {
                let pathData = '';
                const nSafe = Math.max(0.0001, n);
                const angleRad = rotationDegrees * (Math.PI / 180);
                const cosRot = Math.cos(angleRad);
                const sinRot = Math.sin(angleRad);
                for (let i = 0; i <= points; i++) {
                    const t = (i / points) * 2 * Math.PI;
                    const x0 = a * Math.pow(Math.abs(Math.cos(t)), 2 / nSafe) * Math.sign(Math.cos(t));
                    const y0 = b * Math.pow(Math.abs(Math.sin(t)), 2 / nSafe) * Math.sign(Math.sin(t));
                    const x = x0 * cosRot - y0 * sinRot;
                    const y = x0 * sinRot + y0 * cosRot;
                    const svgX = x + 25;
                    const svgY = y + 25;
                    pathData += (i === 0 ? 'M' : 'L') + ` ${svgX} ${svgY}`;
                }
                return pathData + ' Z';
            }

            function applySpring(target, current, velocity) {
                const force = stiffness * (target - current);
                const dampingForce = damping * velocity;
                const acceleration = force - dampingForce;
                velocity += acceleration;
                current += velocity;
                return { current, velocity };
            }

            function applyRotationSpring(target, current, velocity) {
                const diff = target - current;
                const delta = (diff + 180) % 360 - 180;
                const force = rotationStiffness * delta;
                const dampingForce = rotationDamping * velocity;
                const acceleration = force - dampingForce;
                velocity += acceleration;
                current += velocity;
                return { current, velocity };
            }

            function animateCursor() {
                const dx = cursorMouse.x - cursorState.x;
                const dy = cursorMouse.y - cursorState.y;
                cursorState.x += dx * speed;
                cursorState.y += dy * speed;
                cursorSvg.style.transform = `translate3d(${cursorState.x - 25}px, ${cursorState.y - 25}px, 0)`;

                const velocityMag = Math.min(Math.sqrt(dx * dx + dy * dy), 100);
                if (velocityMag > 1) {
                    targetStretch = 1 + (velocityMag / 200);
                    targetRotation = Math.atan2(dy, dx) * (180 / Math.PI);
                } else {
                    targetStretch = 1;
                    targetRotation = Math.round(currentRotation / 360) * 360;
                }

                ({ current: currentN, velocity: velocityN } = applySpring(targetN, currentN, velocityN));
                ({ current: currentSize, velocity: velocitySize } = applySpring(targetSize, currentSize, velocitySize));
                ({ current: currentFillOpacity, velocity: velocityFillOpacity } = applySpring(targetFillOpacity, currentFillOpacity, velocityFillOpacity));
                ({ current: currentRotation, velocity: velocityRotation } = applyRotationSpring(targetRotation, currentRotation, velocityRotation));
                ({ current: currentStretch, velocity: velocityStretch } = applySpring(targetStretch, currentStretch, velocityStretch));

                let finalA, finalB, rotation;
                if (currentN > 1.8 && currentN < 2.2) {
                    finalA = Math.min(24.5, currentSize * currentStretch);
                    finalB = currentSize / currentStretch;
                    rotation = currentRotation;
                } else {
                    rotation = 0;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    if (absDx > absDy) {
                        finalA = Math.min(24.5, currentSize * currentStretch);
                        finalB = currentSize / currentStretch;
                    } else {
                        finalA = currentSize / currentStretch;
                        finalB = Math.min(24.5, currentSize * currentStretch);
                    }
                }

                const newPath = generateSuperellipsePath(finalA, finalB, currentN, rotation);
                cursorPath.setAttribute('d', newPath);
                cursorPath.style.fill = `rgba(56, 189, 248, ${Math.max(0, currentFillOpacity)})`;
                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            setTimeout(() => {
                if (window.renderMathInElement) {
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\(', right: '\\)', display: false},
                            {left: '\\[', right: '\\]', display: true}
                        ]
                    });
                    attachHoverListeners();
                }
            }, 100);
        });
    </script>
</body>
</html>

